const DepGraph = require('dependency-graph').DepGraph;
const Lib = require('.');
const path = require('path');
const util = require('./util');

const DEFAULT_APP_PKG = 'app.application';
const DEFAULT_FEATURE_PKG = 'app.feature';

const DEFAULT_LIFECYCLE = {
  'onCreate': 1,
  'onLoad': 5,
  'onReady': 9
};


function createApplication(opts) {
  opts = parseApplicationOptions(opts);

  const pod = createApplicationPod(opts);
  validateApplicationPod(pod);

  const app = inflatePod(pod);
  loadApplicationPods(app);

  const main = app.paths.main && util.safeRequire(app.paths.main);

  main && !main.isApplication && app._loading.then(main);

  return app;
}

function createApplicationPod(opts) {
  opts.root = util.findRoot(opts.root);

  const pod = createPod('.', opts, false);

  pod.argv = opts.argv;
  pod.envName = opts.envName;
  pod.env = JSON.parse(JSON.stringify(opts.env));

  pod.extends = createPod(pod.extends || opts.appPkg || DEFAULT_APP_PKG, pod);
  pod.id = pod.id || walkThroughtPod(pod.extends, x => x.id).shift();
  // pod.requires = walkThroughtPod(pod).reduce((sum, x) => sum.concat(x.requires), []);

  pod._ctor = pod._ctor.isApplication ? pod._ctor : pod.extends._ctor;

  pod._rconfig = util.getRuntimeConfig(pod.paths.root, pod.id, {}, pod.argv);
  pod._rconfig.env = pod._rconfig.env && pod._rconfig.env[pod.envName] || {};

  pod._uses = [];
  pod._staging = opts.cache || {};
  pod._depGraph = new DepGraph;
  pod._loadingPlan = undefined;
  pod._loadingLevel = undefined;
  pod._loadingLifecycle = undefined;
  pod._loading = undefined;
  pod._bound = false;
  pod._features = [];
  pod.features = {};

  mergeApplicationPodProperties(pod);

  // register app itself to handle their "requires"
  registerPod(pod, pod);

  // create and register pods in dep graph
  pod._uses
    .map(x => createPod(x, pod))
    .map(x => mergePodProperties(x, pod))
    .map(x => validatePod(x, pod))
    .reduce((registered, x) => {
      if (!registered[x.id]) {
        registerPod(x, pod);
        pod.config[x.id] = x.config;
      }
      return registered;
    }, pod._depGraph.nodes);

  // determine the loading plan only if it's possible
  if (!Object.keys(findMissingPods(pod)).length) {
    const depGraph = pod._depGraph;
    const podsArr = getApplicationPods(pod);
    const podsIndex = podsArr.map(x => x.id);
    const getPod = x => podsArr[podsIndex.indexOf(x)];

    const barPods = depGraph.overallOrder(true)
      .filter(x => ~podsIndex.indexOf(x));
    const depPods = depGraph.overallOrder()
      .filter(x => ~podsIndex.indexOf(x) && barPods.indexOf(x) === -1);

    pod._loadingPlan = [barPods, depPods].filter(x => x.length);
    pod._loadingLevel = -1;
    pod._loadingLifecycle = [pod].concat(podsArr)
      .reverse()
      .reduce((obj, x) => Object.assign(obj, x.lifecycle), {});
  }

  return pod;
}

function createPod(filepath, app, recursive) {
  const root = util.findRoot(filepath, app.root);

  if (app._staging && app._staging[root]) {
    return app._staging[root];
  }

  const pod = {id: undefined};
  const paths = pod.paths = util.resolvePackagePaths(root);
  const pkg = pod.pkg = require(paths.pkg);

  pod.id = isTopLevelFeature(pod) ? pkg.name.split('.').pop() : pkg.feature;
  pod.requires = pkg.requires || [];
  pod.extends = undefined;
  pod.lifecycle = Object.assign({}, DEFAULT_LIFECYCLE, pkg.lifecycle);
  pod._ctor = require(paths.main);
  pod._inflater = undefined;
  pod.hiddenProperties = pod._ctor.hiddenProperties || [];
  pod.config = util.deepExtend({}, pod._ctor.config, paths.config && util.safeRequire(paths.config));
  pod.config.env = pod.config.env && pod.config.env[app.envName] || {};
  pod._econfig = undefined;
  pod.lib = util.deepExtend({}, pod._ctor.lib, paths.lib && util.safeRequire(paths.lib));

  if (!pkg.extends && pod._ctor.isFeature && !pod._ctor.isApplication && !isTopLevelFeature(pod)) {
    pod.extends = DEFAULT_FEATURE_PKG;
  }

  if (pkg.extends) {
    pod.extends = util.resolveFrom(root, pkg.extends);
  }

  if (pod.extends && recursive !== false) {
    pod.extends = createPod(pod.extends, app);
  }

  if (!pod.id && pod.extends && recursive !== false) {
    pod.id = walkThroughtPod(pod.extends, x => x.id).shift();
  }

  if (app._staging) {
    app._staging[root] = pod;
  }

  return pod;
}

function findMissingPods(app) {
  return Object.keys(app._depGraph.nodes)
    .filter(key => !app._depGraph.getNodeData(key))
    .map(key => ({[key]: app._depGraph.dependantsOf(key)}))
    .reduce((obj, x) => Object.assign(obj, x), {});
}

function getApplicationPodNames(app) {
  return app._depGraph.overallOrder()
    .filter(fid => fid !== app.id) // MUST NEVER load app itself!
}

function getApplicationPods(app, map) {
  return getApplicationPodNames(app)
    .map(fid => app._depGraph.getNodeData(fid));
}

function inflatePod(pod, app) {
  const inflater = pod._inflater = class extends pod._ctor {
    static get name() {
      return pod._ctor.name;
    }

    constructor(_pod, _app) {
      _pod.app = _app;

      super(_pod, _app);

      const descs = {};
      const isHidden = key => ~_pod.hiddenProperties.indexOf(key);

      Object.keys(_pod)
        .map(key => {
          if (key[0] === '_' && _pod.hiddenProperties.indexOf(key) === -1) {
            _pod.hiddenProperties.push(key);
          }
          return key;
        })
        .map(key => [key, Object.getOwnPropertyDescriptor(_pod, key)])
        .forEach(([key, x]) => descs[key] = Object.assign(x, {
          configurable: true,
          enumerable: !isHidden(key),
          writable: false,
        }));

      _pod.hiddenProperties
        .filter(key => !this.hasOwnProperty(key))
        .forEach(key => Object.defineProperty(this, key, {
          configurable: true,
          enumerable: false,
          writable: true
        }));

      Object.defineProperties(this, descs)
    }
  };

  return new inflater(pod, app);
}

function isTopLevelFeature(pod) {
  return ~[DEFAULT_APP_PKG, DEFAULT_FEATURE_PKG].indexOf(pod.pkg.name);
}

function loadApplicationPods(app) {
  const getPod = x => app._depGraph.nodes[x];
  const lifecycle = Object.keys(sortLifecycleObject(app._loadingLifecycle));

  Object.defineProperty(app, '_loadingLevel', {
    writable: true
  });

  Object.defineProperty(app, '_loading', {
    value:
      // loading loop
      app._loadingPlan.reduce((promise, podNames, i) => {
        return promise.then(() => {
          app.log.info('== LOADING LVL', ++app._loadingLevel);
          return podNames.map(getPod)
            .map(x => inflatePod(x, app))
            .map(f => {
              app._features.push(f);
              app.features[f.id] = f;
              return f;
            });
        })
        .then(pods => {
          return lifecycle.reduce((prom, step) => {
            return prom.then(() => {
              app.log.info('--', step);
              return pods.reduce((_prom, pod) => {
                if (!pod[step]) {
                  return Promise.resolve();
                }
                app.log.info(step, pod.id);
                return new Promise((resolve, reject) => {
                  pod[step].call(pod, resolve, reject);
                });
              }, Promise.resolve());
            })
            .then(() => {
              if (app._loadingLevel === -1 + app._loadingPlan.length && app[step]) {
                app.log.info(step, 'APPLICATION');
                return new Promise((resolve, reject) => {
                  app[step].call(app, resolve, reject);
                });
              }
            });
          }, Promise.resolve());
        })
        .then(() => {
          app.log.info();
        });
      }, Promise.resolve())
      // app is ready now!
      .then(() => Object.defineProperties(app, {
        _bound: {value: true},
        _loadingLevel: {writable: false}
      }))
  });
}

function mergeApplicationPodProperties(pod) {
  // collect "uses" and push these into pod._uses
  walkThroughtPod(pod)
    .map(x => [x._rconfig, x.config]
      .map(conf => [].concat(
        conf && conf.env && conf.env.main && conf.env.main.uses || [],
        conf && conf.main && conf.main.uses || []
      ))
      .reduce((sum, x) => sum.concat(x), [])
    )
    .reduce((sum, x) => sum.concat(x), [])
    .map(request => util.resolveFrom(pod.paths.root, request))
    .filter((x, index, arr) => arr.indexOf(x) === index)
    .forEach(x => pod._uses.push(x));

  // merge rc configs into pod.config
  Object.keys(pod._rconfig || {})
    .filter(key => ['_', 'configs', 'config'].indexOf(key) === -1)
    .filter(key => typeof pod._rconfig[key] === 'object' && !Array.isArray(pod._rconfig[key]))
    .forEach(key => util.deepExtend(pod.config, {[key]: pod._rconfig[key]}));

  // merge pod properties...
  mergePodProperties(pod);

  // ...and override main config with the correct "uses"
  pod.config.main = pod.config.main || {};
  pod.config.main.uses = pod._uses;

  // inject core libs
  util.deepExtend(pod.lib, Lib);

  return pod;
}

function mergePodProperties(pod, app) {
  ['hiddenProperties', 'requires']
    .forEach(x => pod[x] = walkThroughtPod(pod, f => f[x])
      .reduce((arr, x) => arr.concat(x), [])
      .filter((x, index, arr) => arr.indexOf(x) === index)
      .sort());

  ['lib', 'lifecycle']
    .forEach(x => pod[x] = walkThroughtPod(pod, f => f[x])
      .reverse()
      .reduce((obj, x) => util.deepExtend(obj, x), {}));

  pod.lifecycle = sortLifecycleObject(pod.lifecycle);

  pod.config = walkThroughtPod(pod)
    .filter(x => !isTopLevelFeature(x))
    .map(x => x.config)
    .reverse()
    .map(x => {
      pod._econfig = util.deepExtend(pod._econfig || {}, x.env);
      util.deepExtend(x, x.env);
      delete x.env;
      return x;
    })
    .reduce((obj, x) => util.deepExtend(obj, x));

  app && app.config && util.deepExtend(pod.config, app.config[pod.id]);

  return pod;
}

function parseApplicationOptions(opts = {}) {
  if (typeof opts === 'string') {
    opts = {root: opts};
  }

  if (!opts.argv) {
    opts.argv = process.argv.slice(2);
  }

  if (Array.isArray(opts.argv)) {
    opts.argv = require('minimist')(opts.argv);
  }

  if (!opts.env) {
    opts.env = process.env;
  }

  if (!opts.envName) {
    opts.envName = opts.env.NODE_ENV || opts.argv.env || 'development';
  }

  if (!opts.root) {
    opts.root = opts.env.NODE_APP || opts.argv.root || '.';
  }

  return opts;
}

function registerPod(pod, app) {
  if (app._depGraph.nodes[pod.id]) {
    throw new Error('SAME_FEATURE_REGISTERED');
  }

  const depGraph = app._depGraph;
  const requires = walkThroughtPod(pod)
    .map(x => x.requires)
    .reduce((sum, x) => sum.concat(x), []);

  [pod.id].concat(requires)
    .filter(key => !depGraph.hasNode(key))
    .forEach(key => depGraph.addNode(key, undefined));

  depGraph.setNodeData(pod.id, pod);

  requires.forEach(to => depGraph.addDependency(pod.id, to));

  return pod;
}

function sortLifecycleObject(lifecycle) {
  const sorted = Object.assign({}, lifecycle);

  return Object.keys(sorted)
    .sort((a, b) => String(sorted[a]) < String(sorted[b]))
    .reverse()
    .reduce((obj, key) => Object.assign(obj, {[key]: sorted[key]}), {});
}

function validateApplicationPod(pod) {
  if (!pod.id) {
    throw new Error('PKG_FEATURE_FIELD_MISSING');
  }

  if (!getApplicationPodNames(pod).length) {
    throw new Error('APP_VOID');
  }

  const missings = findMissingPods(pod);

  if (Object.keys(missings).length) {
    throw new Error('FEATURE_MISSING '+ JSON.stringify(missings));
  }

  return pod;
}

function validatePod(pod, app) {
  if (!pod) {
    throw new Error('FEATURE_UNKNOW');
  }

  if (!pod.id) {
    throw new Error('PKG_FEATURE_FIELD_MISSING');
  }

  if (!pod.pkg) {
    throw new Error('FEATURE_PKG_NOT_FOUND');
  }

  if (!pod._ctor || !pod._ctor.isFeature) {
    throw new Error('BAD_FEATURE_MAIN');
  }

  if (require(pod.paths.main) !== pod._ctor) {
    throw new Error('BAD_PKG_FOUND');
  }

  if (pod.extends) {
    const extendsCtor = pod.extends._ctor;

    if (!extendsCtor.isParent(pod._ctor)) {
      throw new Error('BAD_FEATURE_EXTENDED');
    }

    if (!pod._ctor.isChild(extendsCtor)) {
      throw new Error('FEATURE_EXTENDING_NOT_HONORED');
    }
  }

  return pod;
}

function walkThroughtPod(pod, handler) {
  return util.walkThrough(pod, 'extends', handler);
}

module.exports = {
  DEFAULT_APP_PKG,
  DEFAULT_FEATURE_PKG,
  DEFAULT_LIFECYCLE,
  createApplication,
  createApplicationPod,
  createPod,
  findMissingPods,
  getApplicationPodNames,
  getApplicationPods,
  inflatePod,
  isTopLevelFeature,
  loadApplicationPods,
  mergeApplicationPodProperties,
  mergePodProperties,
  parseApplicationOptions,
  registerPod,
  sortLifecycleObject,
  validateApplicationPod,
  validatePod,
  walkThroughtPod
};
