const deepExtend = require('deep-extend');
const fs = require('fs');
const path = require('path');
const rc = require('rc');
const supportsColor = require('supports-color');

function addListenerMap(emitter, listenerMap, context, once) {
  const register = emitter[once ? 'once' : 'on'].bind(emitter);

  Object.keys(listenerMap || {})
    .map(event => [event, listenerMap[event]])
    .map(([event, handler]) => [event, context ? handler.bind(context) : handler])
    .forEach(([event, handler]) => register(event, handler));
}

function addListenerMapOnce(emitter, listenerMap, context) {
  return addListenerMap(emitter, listenerMap, context, true);
}

function findPackageJson(cwd, returnPkg) {
  return findUp('package.json', cwd, returnPkg);
}

function findRoot(filepath, cwd) {
  if (filepath[0] === '.') {
    filepath = path.resolve(cwd || '.', filepath);
  }

  let pkg = findPackageJson(require.resolve(filepath));

  if (pkg) {
    return path.dirname(pkg);
  }
}

function findUp(filename, cwd, returnFound) {
  for (let i = path.resolve(cwd || '.').split(path.sep); i.length; i.pop()) {
    try {
      let filepath = path.resolve.apply(null, ['/'].concat(i, filename));

      if(fs.statSync(filepath).isFile()) {
        return returnFound ? require(filepath) : filepath;
      }
    } catch (err) {
      if (['ENOENT', 'ENOTDIR'].indexOf(err.code) === -1) {
        throw err;
      }
    }
  }
}

function getRuntimeConfig(cwd, ...args) {
  return runUnderPath(cwd, () => rc.apply(rc, args));
}

function resolveFrom(basepath, request, safe) {
  if (request[0] === '.') {
    request = path.resolve(basepath, request);
  }

  return safe ? safeResolve(request) : require.resolve(request);
}

function resolvePackagePaths(root) {
  const paths = {root};
  const resolve = path.resolve.bind(null, root);
  const pkg = require(paths.pkg = resolve('package.json'));
  const dirs = Object.assign({config: 'config', lib: 'lib'}, pkg.directories);

  paths.main = safeResolve(resolve(pkg.main || root));

  Object.keys(dirs)
    .map(key => [key, safeResolve(resolve(dirs[key]))])
    .filter(([key, dirpath]) => !!dirpath)
    .forEach(([key, dirpath]) => paths[key] = dirpath);

  return paths;
}

function runUnderPath(cwd, fn) {
  const current = process.cwd();
  process.chdir(cwd);
  const result = fn();
  process.chdir(current);
  return result;
}

function safeRequire(request) {
  if (request = safeResolve(request)) {
    return require(request);
  }
}

function safeResolve(request) {
  try {
    return require.resolve(request);
  } catch (err) {
    if (err.code !== 'MODULE_NOT_FOUND' || err.message.indexOf(request) === -1) {
      throw err;
    }
  }
}

function walkThrough(obj, key, handler) {
  handler = handler || (x => x);
  const stack = [];
  for (let i = obj; !!i && stack.push(i); i = i[key]);
  return stack.map((val, index, arr) => handler(val, index, arr));
}

module.exports = {
  addListenerMap,
  addListenerMapOnce,
  deepExtend,
  findPackageJson,
  findRoot,
  findUp,
  getRuntimeConfig,
  resolveFrom,
  resolvePackagePaths,
  runUnderPath,
  safeRequire,
  safeResolve,
  supportsColor,
  walkThrough
};
