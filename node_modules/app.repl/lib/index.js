const REPL = require('repl');
const fs = require('fs');
const util = require('util');

function bindInspectors(repl) {
  const {app, config} = repl;
  const setInspector = (obj, value) => Object.defineProperty(obj, 'inspect', {
    configurable: true,
    value
  });

  setInspector(app, inspectApplication.bind(app, app, config));
  setInspector(app._features, inspectFeaturesList.bind(app, app._features, config));
  setInspector(app.features, inspectFeaturesMap.bind(app, app.features, config));
  app._features.forEach(f => setInspector(f, inspectFeature.bind(app, f, config)));
}

function formatFeatureName({id, pkg}) {
  return [id, formatPackageName(pkg)].join(' <-- ');
}

function formatPackageName(pkg) {
  return [pkg.name, pkg.version].join(' @ ');
}

function formatApplicationFeatures(app, tab = '  ') {
  return tab + app.lib.pod.getApplicationPodNames(app)
    .sort()
    .map(fid => formatFeatureName(app._depGraph.nodes[fid]))
    .join(`\n${tab}`);
}


function inspectApplication(pod, config) {
  const preview = inspectApplicationPreview(pod);

  const inspection = util.inspect(pod, {
    colors: config.useColors,
    customInspect: false
  });

  return [preview, inspection].join('\n');
}


function inspectApplicationPreview(pod) {
  return `
  ---------------------------------------------------------------
    Application Info
      Id            : ${pod.id}
      Package       : ${formatPackageName(pod.pkg)}
      Extends       : ${pod.extends && formatPackageName(pod.extends.pkg) || ''}
      Requires      : ${pod._depGraph.dependenciesOf(pod.id).sort().join(', ')}
      Environment   : ${pod.envName}
      CLI arguments : ${JSON.stringify(pod.argv)}
      Root          : ${pod.paths.root}

    Features Info ${'\n' + formatApplicationFeatures(pod, '      ')}
  ---------------------------------------------------------------
  `;
}

function inspectFeature(pod, config) {
  const preview = inspectFeaturePreview(pod);

  const inspection = util.inspect(pod, {
    colors: config.useColors,
    customInspect: false
  });

  return [preview, inspection].join('\n');
}

function inspectFeaturePreview(pod) {
  return `
  ---------------------------------------------------------------
    Feature Info
      Id            : ${pod.id}
      Package       : ${formatPackageName(pod.pkg)}
      Extends       : ${pod.extends && formatPackageName(pod.extends.pkg) || ''}
      Requires      : ${pod.requires.join(', ')}
  ---------------------------------------------------------------
`;
}

function inspectFeaturesList(features) {
  return `
  ---------------------------------------------------------------
    Features List
      ${features
        .map((f, i) => `[${i}] ${formatFeatureName(f)}`)
        .join('\n      ')}
  ---------------------------------------------------------------
`;
}

function inspectFeaturesMap(features) {
  return Object.keys(features)
    .sort()
    .map(fid => inspectFeaturePreview(features[fid]))
    .join('');
}

function loadHistory(repl) {
  const {api, config} = repl;

  if (!config.history) {
    return;
  }

  try {
    fs.statSync(config.history);

    fs.readFileSync(config.history).toString()
      .split('\n')
      .reverse()
      .slice(0, config.historySize)
      .filter(line => line.trim())
      .map(line => api.history.push(line))

    repl.log.info(repl.id, '--', 'history loaded');
  } catch (err) {
    if (['ENOENT'].indexOf(err.code) === -1) {
      throw err;
    }

    repl.log.info(repl.id, '--', 'no history found')
  }
}

function prepareConfig(pod) {
  const {app, config} = pod;

  config.history = app.env.NODE_REPL_HISTORY || config.history;
  config.history = String.prototype.trim.call(config.history || '');
  config.history = !!config.history && app.resolveFilename(config.history);

  config.historySize = app.env.NODE_REPL_HISTORY_SIZE || config.historySize;
  config.historySize = Number(config.historySize);

  if (typeof config.useColors === 'undefined') {
    config.useColors = !!app.lib.util.supportsColor;
  }

  config.replMode = app.env.NODE_REPL_MODE || config.replMode;

  if (typeof config.replMode === 'string') {
    config.replMode =
      REPL['REPL_MODE_' + config.replMode.toUpperCase()];
  }

  if (!config.prompt) {
    let prompt = `${pod.app.id} > `;

    if (config.useColors !== false) {
      prompt = [config.promptStyle, prompt, '\u001b[0m'].join('');
    }

    config.prompt = prompt;
  }

  return pod;
}

function saveHistory(repl) {
  const {app, api, config} = repl;
  const lines = (api.history || [])
    .filter(x => !!x.trim())
    .reverse()

  if (!config.history || !lines.length) {
    return;
  }

  api.clearLine();

  try {
    fs.writeFileSync(config.history, lines.join('\n'));

    repl.log.info(repl.id, '--', 'history saved');
  } catch (err) {
    repl.log.error(repl.id, '--', 'failed to save history');
    repl.log.error(err);
  }

  api.history.length = 0;
}

function unbindInspectors(repl) {
  const {app, config} = repl;

  [app, app._features, app.features].concat(app._features)
    .forEach(x => delete x.inspect);
}

module.exports = {
  bindInspectors,
  formatPackageName,
  formatApplicationFeatures,
  inspectApplication,
  inspectApplicationPreview,
  inspectFeature,
  inspectFeaturePreview,
  inspectFeaturesList,
  inspectFeaturesMap,
  loadHistory,
  prepareConfig,
  saveHistory,
  unbindInspectors
};
